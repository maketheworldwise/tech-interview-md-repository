- [쿠키와 세션 \& Same Site Cookie 전략](#쿠키와-세션--same-site-cookie-전략)
- [CORS](#cors)
- [JPA](#jpa)

---

### 쿠키와 세션 & Same Site Cookie 전략

> 💁🏻 : 쿠키는 클라이언트가 저장하는 정보, 세션은 서버가 저장하는 정보다.

HTTP는 일반적으로 Connectionless, Stateless한 특징을 가지고 있다. 따라서 상태를 유지할 수 없기 때문에 쿠키와 세션이 필요한 것이다.

**Cookie**

쿠키는 브라우저가 저장하는 데이터다. 동작 과정은 다음과 같다.

1. 클라이언트가 페이지를 요청
2. 서버에서는 쿠키를 생성하고 HTTP 헤더에 쿠키를 담아 클라이언트에게 전달
3. 넘겨받은 쿠키는 클라이언트의 로컬에 저장
4. 브라우저가 종료되어도 쿠키 만료 기간이 남아 있다면 계속 보관
5. 이 후 서버에 페이지를 요청할 때마다 헤더에 쿠키를 담아 전달

참고로 브라우저단에서 쿠키를 제한할 경우에는 파리미터로 보내는 방식을 이용하면 된다.

**Session**

세션은 일정 시간동안 동일한 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술이다. 일정 시간이란 사용자가 브라우저를 통해 서버에 접속한 시점부터 브라우저를 종료하여 연결을 끝내는 시점을 의미한다.

세션은 클라이언트를 구분하기 위해 세션 ID를 부여하고 브라우저를 종료할 때가지 유지한다. 서버가 관리하기 때문에 쿠키보다 보안적으로 안전하지만 사용자가 많을 수록 서버 메모리를 많이 차지하게 되어 성능 저하의 요인이 될 수 있다. 동작 과정은 다음과 같다.

1. 클라이언트가 페이지를 요청
2. 서버는 접근한 클라이언트의 헤더에서 쿠키를 확인하고 세션 ID가 있는지 확인
3. 세션 ID가 없을 경우 새로 발급해주고 서버에 저장
4. 클라이언트 재접속 시, 발급받은 쿠키로 서버에 전달

**Cookie, Session 보안 이슈**

Cookie 해킹은 정보를 변환하여 서버에 보내는 것을 의미한다. 손쉽게 접할 수 있는 변조 방법은 Edit Cookie 확장 프로그램을 이용하면 된다. 반대로 Session은 두 컴퓨터 사이에서 연결을 가로채는 Session Hijacking이라는 기법을 통해 해킹할 수 있다.

이 보안 이슈를 해결하기 위해서는 제 3자가 추론하기 어렵게 평문 사용을 금지하고 쿠키에 대한 조작을 쉽지 않게 구성하거나 쿠키보다 세션이나 토큰을 사용하는 방법을 권장한다.

**Same Site Cookie**

> 💁🏻 : 동일한 도메인에서만 쿠키 전달을 허용하는 기법이다.

- 퍼스트 파티 쿠키 : 현재 사용자가 접속한 도메인과 같은 도메인으로 전송되는 쿠키
- 서드 파티 쿠키 : 현재 사용자가 접속한 도메인과 다른 도메인으로 전송되는 쿠키

Same Site Cookie 전략은 쿠키의 보안적인 문제를 해결하기 위해 만들어진 기술이다. 즉, 같은 도메인이 아닌 경우에는 쿠키를 전송하지 않는 전략이다. 따라서 서드 파티 쿠키를 심으려는 목적이 아니라면 항상 Same Site Cookie 옵션을 적용하는게 좋다.

Same Site Cookie가 화제가 되었던 이유는 현재 많은 브라우저들이 이를 구현하고 있기 때문이다. 한 때 Same Site Cookie의 기본값이 변경되어 웹 서비스들의 온라인 결제나 인증이 제대로 동작하지 않은 경우가 있었다.

### CORS

> 💁🏻 : CORS는 한 출처에서 다른 출처로의 접근 허용에 해단 옵션이다.

CORS는 Cross Origin Resource Sharing으로 교차 출처 리소스 공유를 의미한다. 한 출처에서 실행중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제다. 그리고 이러한 교차 출처 공유는 보안을 고려해 금지하는 편이다.

요청을 미리 전송하여 안전한지 OPTIONS 메서드로 확인하는 Preflight 요청, 단순히 요청하는 Simple, HTTP Cookie와 Authentication 정보를 인식할 수 있게 해주는 Credential 요청이 있다.

스프링에서는 `HandlerMapping` 구현체는 이미 CORS에 대해 제공을 하고 있다. 요청을 Handler에 성공적으로 매핑이 완료되면 `HandlerMapping` 구현체가 요청에 대해 CORS 설정을 확인한다.

### JPA

> 💁🏻 : Java의 대표적인 ORM으로 객체와 데이터베이스간의 관계를 편리하게 만들어주는 기술이다.

Java에는 대표적으로 데이터베이스와 관련하여 JDBC, SQL Mapper(MyBatis), ORM(JPA) 기술이 있다.

JDBC는 사용하는 데이터베이스에 해당하는 드라이버를 가지고있으면 손쉽게 연결을 할 수 있다. 하지만 간단한 쿼리문을 실행함에도 중복된 코드를 반복적으로 사용하고 복잡한 절차들을 수행해야했다. 이를 해결하기 위해 영속성 프레임워크을 이용한다.

영속성 프레임워크에는 내부적으로 JDBC API를 이용하는데, 이를 SQL Mapper와 ORM으로 분리할 수 있다. SQL Mapper는 객체와 SQL 문을 매핑하여 데이터를 객체화하고 쿼리문과 비즈니스 로직을 분리하여 유지보수성을 높이는 것이 컨셉이였다. 하지만 SQL Mapper에는 데이터베이스에 종속된 쿼리문을 개발자가 직접 구성해야하는 문제가 있었다.

이 단점은 다시 객체와 관계형 데이터베이스를 매핑하는 ORM 기술로 해결할 수 있다. ORM을 이용하면 개발자가 쿼리문에 많은 신경을 쓰지않고 객체와 데이터베이스 테이블간의 패러다임 불일치 문제를 해결한다. 복잡한 쿼리를 구성하는데는 한계가 있어 JPQL같은 기술을 이용하거나 SQL Mapper와 혼합해서 사용하는 방법을 많이 이용한다.

**영속성 컨텍스트**

영속성 컨텍스트는 Entity를 영구적으로 저장하는 환경을 의미한다.

- 1차 캐시를 통해 해당 Entity를 계속 보관하여 사용할 수 있음
- 동일성을 보장 ('==' 비교 가능)
- 쓰기 지연을 통해 트랜잭션 커밋 전까지 SQL을 모아서 보낼 수 있음
- 변경 감지(더티 체킹)를 통해 1차 캐시에 들어온 데이터를 스냅샷 찍어두고 커밋 시점에 비교하여 UPDATE SQL을 생성
- 지연 로딩을 통해 Entity안에서 Entity를 불러올 때 사용 시점에 쿼리를 보내 가져올 수 있음

**저장 과정**

1. JPA는 트랜잭션 실행 단위안에서 동작한다.
2. 1차 캐시로 객체를 영속성 컨텍스트에 등록한다. INSERT 쿼리의 경우 쓰기 지연으로 SQL 저장소에 저장된다.
3. 트랜잭션이 끝나는 시점에 쓰기 지연 SQL 저장소에 있는 쿼리문들이 FLUSH 되고 트랜잭션이 커밋된다.

**수정 과정**

1. 1차 캐시에 등록된 Entity와 스냅샷을 비교하여 변경 내역을 확인하고 UPDATE 쿼리를 쓰기 지연 저장소에 저장한다.
2. 트랜잭션이 끝나는 시점에 쿼리들이 FLUSH 되고 트랜잭션이 커밋된다.

**N+1 문제**

N+1 문제는 하위 Entity들이 첫 쿼리 실행시 한 번에 가져오지 않고 지연 로딩으로 프록시가 들어온 상태에서 후에 이것을 사용하면서 조회 쿼리가 다시 나가게 되어 발생하는 문제다.

예를 들어 학생(N)과 팀(1)에서 양방향 관계를 맺고있을 때 10개의 팀을 꺼내오는 경우를 생각해보면 된다. 10개의 팀을 가져오면서 하나의 쿼리가 전송될것이고, 팀 기준 OneToMany이기에 Lazy로 동작하여 학생은 프록시로 들어오게 된다.

각각의 팀에 대해 학생들에 접근하는 로직이 있다면 각 팀마다 학생들을 조회하는 쿼리가 1개씩 추가로 전송되게 된다. 즉, 10개의 팀을 조회하고 각 팀의 학생들에게 접근한다고 했을 때 10개의 쿼리가 추가로 전송된다는 것이다.

이에 대한 해결책은 Fetch Join과 Batch Size가 있다. Fetch Join을 사용하면 Lazy 로딩으로 프록시로 들어오던 것을 Join으로 한번에 가져올 수 있다. Batch Size는 N+1 문제가 발생하던 것 처럼 프록시로 가져오고 학생들을 가져올 때 쿼리가 한번 더 전송되는데, 이때 IN 쿼리로 Batch Size 개수만큼 가져온다.

예제에서 가져온 팀이 10개고 Batch Size가 5라면 최초에 학생을 가져오는 쿼리에서 WHERE 조건문에 IN 쿼리로 5개의 팀 ID값을 넣어 쿼리를 전송한. 이렇게 되면 결과적으로 학생을 가져오는 쿼리는 2번이 전송되어 총 쿼리는 3개가 전송되는 셈이다. (팀 가져오는 쿼리 + 학생 가져오는 쿼리)

(그 외의 내용은 [면접 시리즈 글](https://velog.io/@backtony/%EB%A9%B4%EC%A0%91-%EC%8B%9C%EB%A6%AC%EC%A6%882-Spring-JPA#onetoone-%EC%96%91%EB%B0%A9%ED%96%A5-%EA%B4%80%EA%B3%84-lazy-%EB%A1%9C%EB%94%A9-%EC%A3%BC%EC%9D%98)에서 확인할 수 있다.)
