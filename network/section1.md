- [TCP vs UDP](#tcp-vs-udp)
- [OSI 7 Layer](#osi-7-layer)
- [3-Way Handshaking \& 4-Way Handshaking](#3-way-handshaking--4-way-handshaking)
- [대칭키 암호화 vs 공개키 암호화](#대칭키-암호화-vs-공개키-암호화)
- [HTTP vs HTTPS](#http-vs-https)

---

### TCP vs UDP

> 💁🏻 : TCP는 신뢰 중심 연결지향형이고 UDP는 연속성 중심 비연결지향형이다.

**TCP**

- 연속성보다 신뢰성있는 전송이 중요할 때 사용
- 발신자와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정하는 가상회선 방식을 제공
- 3-Way Handshaking을 통해 연결하고 4-Way Handshaking을 통해 해제
- 흐름 제어 및 혼잡 제어
- 높은 신뢰성 보장
- 전이중, 점대점 방식

**UDP**

- 신뢰성보다 연속성있는 전송이 중요할 때 사용
- 비연결형 서비스로 데이터그램 방식을 사용
- 정보를 주고 받을 때 신호 절차 없음
- UDP 헤더의 CheckSum 필드를 통해 최소한의 오류를 검출
- 신뢰성이 낮음

### OSI 7 Layer

> 💁🏻 : 물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용 계층을 의미한다.

OSI 7 Layer란 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 표준 규약이다.

- 물리 계층 : 전송할 때 필요한 물리적인 장비 (통신 케이블, 허브 등)
- 데이터 링크 계층 : 송수신을 확인하는 계층 (MAC 주소, 브릿지, 스위치)
- 네트워크 계층 : 패킷을 네트워크 간의 IP를 통해 데이터를 전달 (라우터)
- 전송 계층 : 두 호스트 시스템으로부터 발생하는 데이터의 흐름 (TCP, UDP)
- 세션 계층 : 통신 시스템 사용자간의 연결을 유지 및 설정 (API, Socket)
- 표현 계층 : 세션 계층간의 주고받는 인터페이스를 일관성 있게 제공 (파일 인코딩, 명령어 포장/압축/암호화)
- 응용 계층 : 사용자가 네트워크에 접근할 수 있도록 서비스 제공 (HTTP, FTP, DNS 등)

![](/docs/images/osi-7-layer.png)

### 3-Way Handshaking & 4-Way Handshaking

> 💁🏻 : TCP 통신할 때 연결과 해제의 과정을 담은 개념이다.

**3-Way Handshaking**

1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 전송
2. 서버는 클라이언트의 요청인 SYN 패킷에 대한 요청 수락 응답으로 ACK 패킷과 클라이언트의 포트를 열어달라는 SYN 패킷을 전송
3. 클라이언트는 ACK 패킷과 SYN 패킷을 전달받고 이에 대한 응답으로 ACK 패킷을 보내 연결을 성립

![](/docs/images/3-way-handshaking.png)

**4-Way Handshaking**

1. 클라이언트는 서버에게 연결을 종료하겠다는 FIN 패킷 전송
2. 서버는 클라이언트에게 FIN 패킷에 대한 응답으로 ACK 전송 (처리해야할 자신의 통신이 끝날 때까지 대기)
3. 처리해야할 모든 통신을 끝마쳤을 경우 연결을 종료하겠다는 FIN 패킷 전송
4. 클라이언트는 FIN 패킷에 대한 확인 응답으로 ACK 전송
5. 클라이언트의 ACK 패킷을 받은 서버는 소켓 연결을 닫음
6. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 대기

![](/docs/images/4-way-handshaking.png)

### 대칭키 암호화 vs 공개키 암호화

> 💁🏻 : 대칭키 암호화는 암호화와 복호화에 사용되는 키가 동일한 것을 의미한다. 반면 공개키 암호화는 개인키로만 복호화가 가능하도록 암호키를 대중에게 공개하는 방법이다.

**대칭키 암호화**

대칭키 암호화는 동일한 키를 이용하여 암호화하고 복호화하는 것을 의미한다. 암호화 및 복호화 연산 속도가 빠르다는 장점을 가지고 있지만 키를 전달할 때 노출된다면 보안에 매우 취약할 수 있다는 단점을 가지고 있다.

![](/docs/images/key-symmetric.png)

**공개키 암호화**

공개키 암호화는 대칭키 암호화 방법의 키 전달 취약점을 해결하기 위한 방식이다. 공개키 암호화는 암호화에 사용하는 키와 복호화에 사용하는 키를 분리하여 해결한 방법이다. 따라서 비대칭키 암호화라고도 한다.

결론적으로는 자신이 가지고있는 개인키로만 복호화할 수 있는 공개키를 대중에게 공개하는 방법이다. 즉, 공개된 공개키를 이용하여 전달하고자 하는 데이터를 암호화하고 이를 개인키로 복호화하는 과정이다.

대칭키 암호화의 문제를 해결은 했지만 복호화를 위하 복잡한 수학 연산을 수행하기 때문에 대칭키 방식에 비해 속도가 느리고 복잡하다는 단점이 있다.

![](/docs/images/key-public.png)

### HTTP vs HTTPS

> 💁🏻 : SSL 적용 유무를 의미한다. 보안상 SSL을 적용하는 것을 권장한다.

HTTP는 TCP 기반으로 통신하는 Conectionless, Stateless 특징을 가진다. HTTP는 평문 통신이기 때문에 도청이 가능하고 통신 상대를 확인하지 않아 위장이 가능하며 완전성을 증명할 수 없어 변조가 가능하다.

따라서 HTTP 통신하는 Socket 부분을 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer)이라는 프로토콜로 대체한다. HTTPS에서 HTTP와 SSL과 통신하고 SSL이 TCP와 통신하게 된다. HTTPS의 SSL은 대칭키 암호화와 공개키 암호화 방식을 모두 사용한다.

SSL 프로토콜은 Netscape 사에서 웹 서버와 브라우저 사이의 보안을 위해 만들어졌다. CA(Certificate Authority)라 불리는 서드 파티로부터 서버와 클라이언트의 인증을 하는데 사용된다.

애플리케이션 서버를 운영하는 기업은 CA를 통해 인증서를 만드는 과정은 다음과 같다.

1. 애플리케이션 서버를 운영하는 기업은 HTTPS 적용을 위해 공개키와 개인키를 생성
2. 신뢰할 수 있는 CA 기업을 선택하고 인증서 생성을 요청
3. CA는 서버의 공개키, 암호화 방법 등의 정보를 담은 인증서를 만들고 해당 CA의 개인키로 암호화하여 서버에 제공
4. 클라이언트가 SSL로 암호화된 페이지를 요청시 서버는 인증서를 전송

클라이언트와 서버의 통신 흐름은 다음과 같다.

1. 클라이언트가 SSL로 암호화된 페이지를 요청
2. 서버는 클라이언트에게 인증서를 전송
3. 클라이언트는 인증서가 신용이 있는 CA로부터 서명된 것인지 확인 (전자 서명)
4. 클라이언트는 CA의 공개키를 이용해 인증서를 복호화하고 서버의 공개키를 획득
5. 클라이언트는 서버의 공개키를 이용해 랜덤 대칭 암호화키, 데이터 등을 암호화하여 서버로 전송
6. 서버는 자신의 개인키를 이용해 복호화하고 랜덤 대칭 암호화키, 데이터 등을 획득
7. 서버는 랜덤 대칭 암호화키로 클라이언트 요청에 대한 응답을 암호화하여 전송
8. 클라이언트는 랜덤 대칭 암호화키를 이용해 복호화하고 데이터를 이용

모든 웹 페이지에서는 HTTPS 통신을 하지는 않는다. 그 이유는 평문 통신에 비해 암호화 통신은 CPU나 메모리 등 리소스를 많이 필요로하기 때문이다. 따라서 통신을 할 때마다 암호화를 하면 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 요청의 수가 줄어들게 된다. 그렇기 때문에 민감한 정보만을 다룰 때만 HTTPS에 의한 암호화 통신을 사용한다.
