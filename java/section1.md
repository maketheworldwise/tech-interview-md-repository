- [객체지향(OPP) vs 절차치향(PP)](#객체지향opp-vs-절차치향pp)
- [객체지향(OPP) 4가지 특징](#객체지향opp-4가지-특징)
- [객체지향(OPP) 5대 원칙](#객체지향opp-5대-원칙)
- [Java의 장단점](#java의-장단점)
- [Java의 접근제어자](#java의-접근제어자)
- [오버로딩(Overloading) vs 오버라이딩(Overriding)](#오버로딩overloading-vs-오버라이딩overriding)
- [객체 vs 클래스 vs 인스턴스](#객체-vs-클래스-vs-인스턴스)
- [인터페이스 vs 추상 클래스](#인터페이스-vs-추상-클래스)

---

### 객체지향(OPP) vs 절차치향(PP)

> 💁🏻 : 객체지향은 실세상의 물체를 빗대어 상태와 행위를 가진 객체로 만들고 그 객체들간의 상호작용을 통해 로직을 구현하는 프로그래밍 기법이다. 반면 절차지향은 말그대로 절차, 순서를 지키며 구현하는 프로그래밍 기법을 의미한다.

**객체지향**

객체지향은 실세계를 모델링하여 개발하는 방법이다. 모든 데이터를 추상화하여 상태와 행위를 가진 객체로 표현하고 그 객체들간의 유기적인 상호작용을 통해 구현하는 프로그래밍 방식이다. 코드 재사용성과 유지보수에 유리하다는 장점이 있다.

하지만 처리 속도가 상대적으로 느리고 객체가 많아질 수록 용량이 커질 수 있으며 설계 단계에서 많은 시간과 노력이 필요하다.

**절차지향**

C언어가 절차지향의 대표적인 언어다. 순차적인 처리가 중요시되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리하다.

하지만 유지보수 측면에서 어려운면(+디버깅)을 가진 프로그래밍 기법이다. 실행 순서가 정해져있어 코드의 순서가 바뀔 경우 동일한 결과를 보장하기 어렵다.

### 객체지향(OPP) 4가지 특징

> 💁🏻 : 캡상추다 (캡슐화, 상속, 추상화, 다형성)!
>
> - 추상화는 공통 분야로 묶어 표현하는 방법
> - 상속은 재사용과 확장의 개념 (is-a-kind-of, 다중 상속을 지원하지 않음)
> - 다형성은 오버로딩과 오버라이딩을 의미
> - 캡슐화는 정보 은닉을 의미 (접근제어자)

**추상화**

객체지향에서의 추상화는 구체적인 것을 분해해서 애플리케이션 경계(관심 영역)에 있는 특성만 가지고 재조합하는 것을 의미한다.

**상속**

상속은 부모와 자식 관계가 아닌 재활용과 확장의 개념이다. 왜 inheritance 키워드를 사용하지 않는지를 생각하면 이해가된다.

상속은 기본적으로 다중 상속을 할 수 없다. 대표적인 예시로 인어공주를 생각하면된다. 인어공주가 수영을 한다면 지느러미로 해야할지 혹은 손과 다리로 헤엄쳐야할지에 대한 애매한 문제가 발생하기 때문이다.

**다형성**

(오버라이딩과 오버로딩에 대한 내용은 면접에서 많이 나오는 내용인만큼 하단에 별도로 정리해놓았다.)

**캡슐화**

캡슐화는 정보 은닉을 의미한다. 데이터를 처리할 때 외부로 노출하지 않고 객체 내부에서 처리되도록 하기 때문이다. 캡슐화의 특징을 이용한다면 유지보수 향상과 코드의 중복성을 줄여주는데 큰 역할을 수행할 수 있다.

[캡슐화란 무엇인가? 어떤 이점이 있는가?](https://bperhaps.tistory.com/entry/%EC%BA%A1%EC%8A%90%ED%99%94%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%EC%96%B4%EB%96%A4-%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EB%8A%94%EA%B0%80) 글을 살펴보면 캡슐화의 장점들을 이해할 수 있다. 글을 쉽게 요약하자면 - 비즈니스 로직을 별도의 메서드로 분리함으로서 코드의 중복성을 줄이고 유지보수할 때 비즈니스 로직만을 수정하여 해당 메서드를 사용하고 있는 코드들을 건드리지 않을 수 있다는 내용이다. (사용하는 곳은 로직을 모른다!)

이해가 되지 않는다면 속성과 기능을 정의하는 멤버 변수와 메서드를 클래스라는 캡슐에 넣어 한곳으로 모아 이점을 챙기는 것이라고 생각하면 된다.

(접근 제어자에 관련된 내용은 별도로 정리해놓았다.)

### 객체지향(OPP) 5대 원칙

> 💁🏻 : 객체지향의 5대 원칙은 SOLID를 의미한다... 여기까지...
>
> - 단일 책임 원칙
> - 개방 폐쇄 원칙
> - 리스코프 치환 원칙
> - 인터페이스 분리 원칙
> - 의존 역전 원칙

**단일 책임 원칙**

클래스를 변경해야하는 이유는 오직 하나뿐이어야 한다. (응집도는 높게, 결합도는 낮게!)

**개방 폐쇄 원칙**

자신의 확장은 열려있지만 주변의 변화에는 닫혀있어야 한다. 즉, 기존의 코드를 변경하지 않고(closed) 기능을 수정하거나 추가할 수 있도록(open) 설계해야한다. 설계할 때는 변경되는 것이 무엇인가에 초점을 맞춰야한다.

**리스코프 치환 원칙**

쉽게 말하자면 is-a-kind-of, is-able-to 문장을 지켜야한다. 즉, 하위 클래스는 상위 클래스에서 가능한 행위를 수행할 수 있어야한다.

**인터페이스 분리 원칙**

특별한 경우가 아니면 단일 책임 원칙을 적용하는게 좋지만 그 외의 상황에서는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.

상위 클래스는 물려줄 특성이 풍성할 수록 좋고, 인터페이스는 구현을 강제할 메소드의 개수가 적을 수록 좋다는 최소주의 원칙을 지켜야한다.

**의존 역전 원칙**

자주 변경되는 구체적인 것은 추상화된 것에 의존해야한다. 즉, 의존관계를 맺을 때 변하기 쉬운것보다 변하기 어려운것에 의존해야한다.

### Java의 장단점

> 💁🏻 : 언제 어디서든 실행할 수 있다(?)

Java는 JVM에서 동작하기 때문에 운영체제에 독립적이다. 대표적인 객체지향 언어이며 자동으로 메모리를 관리(GC)해주고 멀티스레드 구현과 동적 로딩을 지원한다는 장점을 가지고 있다.

다만, 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 비교적으로 속도가 느리다. 하지만 하드웨어의 성능 향상과 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 기술 적용으로 JVM의 기능이 향상되어 속도의 격차가 많이 줄어들었다.

(JIT 컴파일러에 대한 내용은 JVM 구조에 별도로 정리해놓았다.)

### Java의 접근제어자

> 💁🏻 : `private, public, default, protected`가 있다.
>
> - `private` : 해당 클래스 안에서만
> - `public` : 어디든
> - `default` : 패키지 안에서만
> - `protected` : 상속, 패키지 안에서만

![](/docs/images/access-modifier.png)

### 오버로딩(Overloading) vs 오버라이딩(Overriding)

> 💁🏻 : 같은 메서드 이름을 가지지만 매개변수가 다른 것을 오버로딩, 매개변수마저 같은 것을 오버라이딩이라 한다.

**오버로딩**

오버로딩은 같은 이름의 메서드를 여러 개 가지면서 매개변수의 타입과 개수를 다르게 하여 정의하는 것을 의미한다.

**오버라이딩**

오버라이딩은 상위 클래스가 가지고 있는 메서드를 하위 클래스에서 재정의하여 사용하는 것을 의미한다. 상속을 할 때는 상위 클래스의 `private` 멤버를 제외한 모든 멤버를 상속받는다.

### 객체 vs 클래스 vs 인스턴스

> 💁🏻 : 클래스를 이용하여 객체 혹은 인스턴스를 생성하는 개념이다. 객체와 인스턴스간의 차이는 크게 없지만 객체가 더 포괄적인 의미로 알고 있다.

**클래스**

클래스는 설계도를 의미한다. 쉽게 표현하자면 클래스는 분류, 집합 같은 속성과 기능을 가진 객체를 총칭하는 개념이다. (사람, 펭귄)

**객체**

객체는 설계도로 구현한 모든 대상을 의미한다. 쉽게 표현한다면 객체는 세상에 존재하는 유일무이한 사물을 의미한다. (김연아, 뽀로로)

**인스턴스**

클래스는 영어로 `class`, 객체는 영어로 `object`다. 결국 `class`로 `object`를 만들어냈다는 의미가 되는데, `object`라는 표현보다는 클래스의 인스턴스라는 표현을 사용한다는 내용도 있다.

내가 참고한 레퍼런스에 따르면, 클래스 타입으로 선언되었을 때를 객체라 부르고 그 객체가 메모리에 할당되어 실제 사용될 때를 인스턴스라고 한다. (객체는 실체, 인스턴스는 관계에 초점에 맞춘다.)

### 인터페이스 vs 추상 클래스

> 💁🏻 : 둘 다 구현할 기능에 대한 명세서의 개념으로 보고 있다. 다만 추상 클래스는 공통된 기능을 묶어 처리하기 위한 용도가 강한 느낌이다.

**인터페이스**

상속 받을 서브 클래스에게 구현할 메서드들의 원형을 모두 알려주어 클래스가 자신의 목적에 맞게 메서드를 구현하도록 하는것이다. 구현 객체의 같은 동작을 보장하기 위한 목적이 있다. 즉, 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용한다.

**추상 클래스**

추상 클래스는 상속을 위한 상위 클래스로 활용하기 위함이다. 여러 클래스들의 공통된 부분을 추상화하여 상속받는 클래스에게 구현을 강제화하기 위해 사용된다. 즉, 추상 클래스의 추상 메서드를 하위 클래스가 구체화하여 그 기능을 확장하는 데 목적이 있다.
